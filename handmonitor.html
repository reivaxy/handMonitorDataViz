<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="css/handmonitor.css"/>


<body>
<h1 id="title" style="display:none"></h1>
<div id="drop_zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);">
    <p>Drag one or more files to this Drop Zone ...</p>
</div>
<div>

    <div class="row">
        <div id="chart_placeholder">
            <input type="range" id="slider">
            <button type="button" class="btn btn-default zoombutton" id="zoom_in"><i class="fa fa-plus"></i></button>
            <button type="button" class="btn btn-default zoombutton" id="zoom_out"><i class="fa fa-minus"></i></button>
        </div>
    </div>
</div>
</body>
<script src="js/jquery/jquery-3.5.1.min.js"></script>
<script src="js/d3/d3.min.js"></script>

<script>

    function dragOverHandler(ev) {
        ev.preventDefault();
    }

    function updateTitle(fileName) {
        let fileParts = fileName.split('.');
        let dateParts = fileParts[0].split('_');
        let mois = ["", "Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août",
            "Septembre", "Octobre", "Novembre", "Décembre"][+dateParts[1]];
        $("#title").text("Données de " + mois + " " + dateParts[0]);
        $("#title").show();
    }

    function processFile(file) {
        var reader = new FileReader();
        reader.onload = function (e) {
            let fileLines = e.target.result.split(/\r\n|\r|\n/);
            let dataSet = [];
            let previous = 0;
            for (i = 0; i < fileLines.length; i++) {
                let lineData = fileLines[i].split(',');
                // Compatibility with previous file format which was space separated
                if (lineData.length == 1) {
                    lineData = fileLines[i].split(' ');
                    let dDate = lineData.shift();
                    lineData[0] = dDate + " " + lineData[0];
                }
                let jData = {
                    date: parseDate(lineData[0]),
                    value: +lineData[1]
                }
                if (i != 0 && previous != jData.value) {
                    dataSet.push({
                        date: parseDate(lineData[0]),
                        value: previous
                    })
                }
                previous = +lineData[1];
                dataSet.push(jData);
            }
            processData(dataSet);
        }
        reader.readAsText(file);
    }

    function dropHandler(ev) {
        console.log('File(s) dropped');
        $("#drop_zone").hide();
        // Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();

        if (ev.dataTransfer.items) {
            // Use DataTransferItemList interface to access the file(s)
            for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                // If dropped items aren't files, reject them
                if (ev.dataTransfer.items[i].kind === 'file') {
                    var file = ev.dataTransfer.items[i].getAsFile();
                    console.log('... file[' + i + '].name = ' + file.name);
                    updateTitle(file.name);
                    if (file.type.indexOf("application/vnd.ms-excel") == 0 ||
                        file.type.indexOf("text/plain") == 0) {
                        processFile(file);
                    }
                }
            }
        } else {
            // Use DataTransfer interface to access the file(s)
            for (var i = 0; i < ev.dataTransfer.files.length; i++) {
                console.log('... file[' + i + '].name = ' + ev.dataTransfer.files[i].name);
                updateTitle(ev.dataTransfer.files[i].name);
                if (ev.dataTransfer.files[i].type.indexOf("application/vnd.ms-excel") == 0 ||
                    ev.dataTransfer.files[i].type.indexOf("text/plain") == 0) {
                    processFile(ev.dataTransfer.files[i]);
                }
            }
        }
    }

    var margin = {top: 10, right: 10, bottom: 100, left: 40},
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    var parseDate = d3.time.format("%d/%m/%Y %H:%M:%S").parse;

    var x = d3.time.scale().range([0, width]),
        y = d3.scale.linear().range([height, 0]);

    var xAxis = d3.svg.axis().scale(x).orient("bottom"),
        yAxis = d3.svg.axis().scale(y).orient("left");

    yAxis.tickFormat(function (d, i) {
        if (d == 1) return "porté"; else return "";
    });
    let defaultTick = x.tickFormat();
    xAxis.tickFormat(function (d, i) {
        let label = defaultTick(d, i).split(' ');
        let translation = label[0];
        switch (label[0]) {
            case "Mon":
                translation = "Lundi";
                break;
            case "Tue":
                translation = "Mardi";
                break;
            case "Wed":
                translation = "Mercredi";
                break;
            case "Thu":
                translation = "Jeudi";
                break;
            case "Fri":
                translation = "Vendredi";
                break;
            case "Sat":
                translation = "Samedi";
                break;
            case "Sun":
                translation = "Dimanche";
                break;

            // months
            case "Jan":
                translation = "Janvier";
                break;
            case "Feb":
                translation = "Février";
                break;
            case "Mar":
                translation = "Mars";
                break;
            case "Apr":
                translation = "Avril";
                break;
            case "May":
                translation = "Mai";
                break;
            case "Jun":
                translation = "Juin";
                break;
            case "Jul":
                translation = "Juillet";
                break;
            case "Aug":
                translation = "Août";
                break;
            case "Sep":
                translation = "Septembre";
                break;
            case "Oct":
                translation = "Octobre";
                break;
            case "Nov":
                translation = "Novembre";
                break;
            case "Dec":
                translation = "Décembre";
                break;


        }
        if (label[1]) {
            return translation + " " + label[1];
        } else {
            return translation;
        }
    });

    var area = d3.svg.area()
        .x(function (d) {
            return x(d.date);
        })
        .y0(height)
        .y1(function (d) {
            return y(d.value);
        });

    var svg = d3.select("#chart_placeholder").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

    svg.append("defs").append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", height);

    var focus = svg.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var zoom = d3.behavior.zoom()
        .on("zoom", draw);
    // Add rect cover the zoomed graph and attach zoom event.
    var rect = svg.append("svg:rect")
        .attr("class", "pane")
        .attr("width", width)
        .attr("height", height)
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .call(zoom);

    const zoomButtons = d3.selectAll('.zoombutton')
        .on('click', zoomClick);

    const slider = d3.selectAll('#slider')
        .attr("value", 1)
        .attr("min", 1)
        .attr("max", 100)
        .attr("step", .5)
        .on("input", slided);

    function processData(data) {
        x.domain(d3.extent(data.map(function (d) {
            return d.date;
        })));
        y.domain([0, d3.max(data.map(function (d) {
            return d.value;
        }))]);


        // Set up zoom behavior
        zoom.x(x);

        focus.append("path")
            .datum(data)
            .attr("class", "area")
            .attr("d", area);

        focus.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

        focus.append("g")
            .attr("class", "y axis")
            .call(yAxis);

    }

    function draw() {
        focus.select(".area").attr("d", area);
        focus.select(".x.axis").call(xAxis);
        d3.select('#slider').property('value', zoom.scale());
    }

    function slided(d) {
        var center = [width / 2, height / 2],
            extent = zoom.scaleExtent(),
            translate = zoom.translate(),
            translate0 = [],
            l = [],
            view = {x: translate[0], y: translate[1], k: zoom.scale()};

        d3.event.preventDefault();

        translate0 = [(center[0] - view.x) / view.k, (center[1] - view.y) / view.k];
        view.k = d3.select(this).property("value");
        l = [translate0[0] * view.k + view.x, translate0[1] * view.k + view.y];

        view.x += center[0] - l[0];
        view.y += center[1] - l[1];
        interpolateZoom([view.x, view.y], view.k, 0);
    }

    function interpolateZoom(translate, scale, duration) {
        var self = this;
        return d3.transition().duration(duration).tween("zoom", function () {
            var iTranslate = d3.interpolate(zoom.translate(), translate),
                iScale = d3.interpolate(zoom.scale(), scale);
            return function (t) {
                zoom
                    .scale(iScale(t))
                    .translate(iTranslate(t));
                zoom.event(focus);
            };
        });
    }

    function zoomClick() {
        var clicked = d3.event.target,
            direction = 1,
            factor = 0.5,
            target_zoom = 1,
            center = [width / 2, height / 2],
            extent = zoom.scaleExtent(),
            translate = zoom.translate(),
            translate0 = [],
            l = [],
            view = {x: translate[0], y: translate[1], k: zoom.scale()};

        d3.event.preventDefault();
        direction = (this.id === 'zoom_in') ? 1 : -1;
        target_zoom = zoom.scale() * (1 + factor * direction);

        if (target_zoom < extent[0] || target_zoom > extent[1]) {
            return false;
        }

        translate0 = [(center[0] - view.x) / view.k, (center[1] - view.y) / view.k];
        view.k = target_zoom;
        l = [translate0[0] * view.k + view.x, translate0[1] * view.k + view.y];

        view.x += center[0] - l[0];
        view.y += center[1] - l[1];
        interpolateZoom([view.x, view.y], view.k, 100);
    }

</script>